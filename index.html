<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Tiny Tower Defense</title>
  <style>
    /* Style canvas with a border */
    canvas {
      border: 1px solid black;
      display: block; /* Ensure canvas is a block element for centering */
    }
    /* Center canvas and set background */
    body {
      margin: 0;
      padding: 0;
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      background-color: #f0f0f0;
    }
    /* Fullscreen button styles */
    #fullscreenButton {
      position: absolute;
      top: 10px;
      right: 10px;
      padding: 10px;
      background-color: #eee;
      border: 1px solid black;
      cursor: pointer;
      display: none; /* Hidden by default */
    }
    /* Show button only on mobile devices */
    @media (max-width: 768px) {
      #fullscreenButton {
        display: block;
      }
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas" width="1200" height="770"></canvas>
  <button id="fullscreenButton">Toggle Fullscreen</button>
  <audio id="backgroundAudio" loop preload="auto">
    <source src="sound/static_rumble.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <script type="module">
    // Game constants for settings and tower properties
    const CONSTANTS = {
      GRID_SIZE: 20,                  // Grid dimensions (20x20)
      TILE: { WIDTH: 64, HEIGHT: 32 }, // Tile size in pixels
      COLORS: {
        STREET: 'gray',               // Street tile color
        BUILDING: 'green',            // Building tile color
        PARKING_LOT: 'gray',          // Parking lot tile color
        BASE: 'yellow'                // Base tile color
      },
      TOWER_TYPES: [                  // Tower definitions with upgrades
        { 
          name: 'Basic', cost: 50, range: 3, color: 'red', effect: 'damage', damage: 20, cooldown: 500,
          upgrades: [
            { costMultiplier: 1.5, damageMultiplier: 1.5, rangeMultiplier: 1.1 },
            { costMultiplier: 2, damageMultiplier: 2, rangeMultiplier: 1.2 }
          ]
        },
        { 
          name: 'Slow', cost: 75, range: 5, color: 'blue', effect: 'slow', slowFactor: 0.5, slowDuration: 2000, cooldown: 1000,
          upgrades: [
            { costMultiplier: 1.5, slowFactor: 0.4, slowDuration: 3000, rangeMultiplier: 1.1 },
            { costMultiplier: 2, slowFactor: 0.3, slowDuration: 4000, rangeMultiplier: 1.2, addFreeze: true } // Adds brief freeze at level 3
          ]
        },
        { 
          name: 'Area', cost: 100, range: 4, color: 'purple', effect: 'area', areaDamage: 10, cooldown: 1000,
          upgrades: [
            { costMultiplier: 1.5, areaDamageMultiplier: 1.5, rangeMultiplier: 1.2 },
            { costMultiplier: 2, areaDamageMultiplier: 2, rangeMultiplier: 1.3 }
          ]
        },
        { 
          name: 'DoT', cost: 100, range: 4, color: 'pink', effect: 'dot', dotDamage: 12, dotDuration: 40000, cooldown: 1000,
          upgrades: [
            { costMultiplier: 1.5, dotDamageMultiplier: 1.5, dotDurationMultiplier: 1.2 },
            { costMultiplier: 2, dotDamageMultiplier: 2, dotDurationMultiplier: 1.5 }
          ]
        }
      ],
      ENEMY_TYPES: [                  // Enemy definitions
        { name: 'Basic', baseHealth: 100, healthPerLevel: 20, speed: 0.5, damage: 10, color: 'black', radius: 10, reward: 5, spawnMultiplier: 1.0 },
        { name: 'Fast', baseHealth: 40, healthPerLevel: 10, speed: 1.0, damage: 5, color: 'red', radius: 7, reward: 3, spawnMultiplier: 3 },
        { name: 'Tank', baseHealth: 2000, healthPerLevel: 700, speed: 0.3, damage: 20, color: 'blue', radius: 15, reward: 10, spawnMultiplier: 0.3 }
      ],
      INITIAL_MONEY: 150,             // Starting money
      BASE_HEALTH: 100,               // Starting base health
      UI: { HEIGHT: 192, Y: 608 },      // UI position and size (increased height for additional row)
      MAX_WAVES_PER_LEVEL: 25         // Waves per level before endless option
    };

    // Seeded random number generator (Linear Congruential Generator)
    class SeededRandom {
      constructor(seed) {
        this.seed = seed;
      }
      // Generate next random number between 0 and 1
      next() {
        this.seed = (1664525 * this.seed + 1013904223) % 4294967296;
        return this.seed / 4294967296;
      }
      // Generate random integer in range [min, max)
      nextInt(min, max) {
        return Math.floor(this.next() * (max - min)) + min;
      }
    }

    // Utility functions for coordinate conversions and distance
    const Utils = {
      // Convert grid (i,j) to screen (x,y)
      gridToScreen(i, j, offsetX, offsetY) {
        return {
          x: (i - j) * (CONSTANTS.TILE.WIDTH / 2) + offsetX,
          y: (i + j) * (CONSTANTS.TILE.HEIGHT / 2) + offsetY
        };
      },
      // Convert screen (x,y) to grid (i,j)
      screenToGrid(x, y, offsetX, offsetY) {
        x -= offsetX;
        y -= offsetY;
        const i = Math.round((x / (CONSTANTS.TILE.WIDTH / 2) + y / (CONSTANTS.TILE.HEIGHT / 2)) / 2);
        const j = Math.round((y / (CONSTANTS.TILE.HEIGHT / 2) - x / (CONSTANTS.TILE.WIDTH / 2)) / 2);
        return (i >= 0 && i < CONSTANTS.GRID_SIZE && j >= 0 && j < CONSTANTS.GRID_SIZE) ? { i, j } : null;
      },
      // Calculate Euclidean distance
      distance(x1, y1, x2, y2) {
        return Math.hypot(x2 - x1, y2 - y1);
      }
    };

    // Manages visual effects (lasers, auras, pulses)
    class EffectManager {
      constructor() {
        this.effects = []; // Array to store active effects
      }

      // Add new effect with type, properties, and duration
      add(type, props, duration) {
        this.effects.push({ type, ...props, startTime: performance.now(), duration });
      }

      // Remove expired effects
      update(time) {
        this.effects = this.effects.filter(e => time < e.startTime + e.duration);
      }

      // Render all active effects
      draw(ctx) {
        this.effects.forEach(e => {
          const progress = (performance.now() - e.startTime) / e.duration;
          ctx.save();
          ctx.beginPath();
          switch (e.type) {
            case 'laser':
              ctx.strokeStyle = 'red';
              ctx.lineWidth = 2;
              ctx.moveTo(e.startX, e.startY);
              ctx.lineTo(e.endX, e.endY);
              ctx.stroke();
              break;
            case 'slowAura':
              ctx.ellipse(e.x, e.y, 15, 7.5, 0, 0, Math.PI * 2);
              ctx.fillStyle = '#00f2';
              ctx.fill();
              break;
            case 'areaPulse':
              ctx.ellipse(e.x, e.y, e.radiusX * progress, e.radiusY * progress, 0, 0, Math.PI * 2);
              ctx.strokeStyle = `rgba(128, 0, 128, ${1 - progress})`;
              ctx.lineWidth = 3;
              ctx.stroke();
              break;
            case 'dotIndicator':
              ctx.arc(e.x, e.y, 5, 0, Math.PI * 2);
              ctx.fillStyle = 'pink';
              ctx.fill();
              break;
            case 'upgradeGlow':
              ctx.ellipse(e.x, e.y, 20 * progress, 10 * progress, 0, 0, Math.PI * 2);
              ctx.strokeStyle = `rgba(255, 255, 0, ${1 - progress})`;
              ctx.lineWidth = 2;
              ctx.stroke();
              break;
          }
          ctx.restore();
        });
      }
    }

    // A* pathfinding for enemy movement
    class Pathfinding {
      // Manhattan distance heuristic
      static heuristic(a, b) {
        return Math.abs(a.i - b.i) + Math.abs(a.j - b.j);
      }

      // Get valid adjacent cells
      static getNeighbors(node, grid, towers) {
        return [[-1, 0], [1, 0], [0, -1], [0, 1]].map(([di, dj]) => ({ i: node.i + di, j: node.j + dj }))
          .filter(n => 
            n.i >= 0 && n.i < CONSTANTS.GRID_SIZE && 
            n.j >= 0 && n.j < CONSTANTS.GRID_SIZE &&
            [CONSTANTS.COLORS.STREET, CONSTANTS.COLORS.PARKING_LOT, CONSTANTS.COLORS.BASE].includes(grid[n.i][n.j]) &&
            !towers.some(t => t.i === n.i && t.j === n.j)
          );
      }

      // Find shortest path using A* algorithm
      static aStar(start, goal, grid, towers) {
        const open = [start];
        const cameFrom = new Map();
        const gScore = new Map([[`${start.i},${start.j}`, 0]]);
        const fScore = new Map([[`${start.i},${start.j}`, this.heuristic(start, goal)]]);
        const key = n => `${n.i},${n.j}`;
        
        while (open.length) {
          // Get node with lowest fScore
          const current = open.sort((a, b) => fScore.get(key(a)) - fScore.get(key(b))).shift();
          // Check if goal reached
          if (current.i === goal.i && current.j === goal.j) {
            // Reconstruct path
            const path = [];
            let node = current;
            while (node) {
              path.push(node);
              node = cameFrom.get(key(node));
            }
            return path.reverse();
          }
          // Process neighbors
          this.getNeighbors(current, grid, towers).forEach(neighbor => {
            const nKey = key(neighbor);
            const g = gScore.get(key(current)) + 1;
            // Update scores if better path found
            if (!gScore.has(nKey) || g < gScore.get(nKey)) {
              cameFrom.set(nKey, current);
              gScore.set(nKey, g);
              fScore.set(nKey, g + this.heuristic(neighbor, goal));
              if (!open.some(n => n.i === neighbor.i && n.j === neighbor.j)) {
                open.push(neighbor);
              }
            }
          });
        }
        return null; // No path found
      }
    }

    // Represents a defensive tower
    class Tower {
      constructor(i, j, type, game) {
        this.i = i;                   // Grid row
        this.j = j;                   // Grid column
        this.type = type;             // Tower type index
        this.game = game;             // Game instance
        this.level = 1;               // Starting level
        this.maxLevel = CONSTANTS.TOWER_TYPES[type].upgrades.length + 1; // Max level
        this.updateSpecs();           // Initialize specs based on level
        this.lastShot = 0;            // Last shot timestamp
      }

      // Update specs based on current level
      updateSpecs() {
        const baseSpec = CONSTANTS.TOWER_TYPES[this.type];
        this.spec = { ...baseSpec };
        for (let lvl = 1; lvl < this.level; lvl++) {
          const upgrade = baseSpec.upgrades[lvl - 1];
          if (upgrade.damageMultiplier) this.spec.damage *= upgrade.damageMultiplier;
          if (upgrade.rangeMultiplier) this.spec.range *= upgrade.rangeMultiplier;
          if (upgrade.areaDamageMultiplier) this.spec.areaDamage *= upgrade.areaDamageMultiplier;
          if (upgrade.dotDamageMultiplier) this.spec.dotDamage *= upgrade.dotDamageMultiplier;
          if (upgrade.dotDurationMultiplier) this.spec.dotDuration *= upgrade.dotDurationMultiplier;
          if (upgrade.slowFactor) this.spec.slowFactor = upgrade.slowFactor;
          if (upgrade.slowDuration) this.spec.slowDuration = upgrade.slowDuration;
          if (upgrade.addFreeze) this.spec.addFreeze = true; // Special effect for level 3 slow
        }
      }

      // Upgrade the tower if possible
      upgrade() {
        if (this.level >= this.maxLevel) return false;
        const upgradeCost = this.getUpgradeCost();
        if (this.game.money < upgradeCost) return false;
        this.level++;
        this.updateSpecs();
        this.game.money -= upgradeCost;
        const { x, y } = Utils.gridToScreen(this.i, this.j, this.game.offsetX, this.game.offsetY);
        this.game.effects.add('upgradeGlow', { x, y }, 500);
        return true;
      }

      // Get cost for next upgrade
      getUpgradeCost() {
        if (this.level >= this.maxLevel) return Infinity;
        const baseCost = CONSTANTS.TOWER_TYPES[this.type].cost;
        const upgrade = CONSTANTS.TOWER_TYPES[this.type].upgrades[this.level - 1];
        return Math.floor(baseCost * upgrade.costMultiplier);
      }

      // Render tower with range circle and level indicator
      draw(ctx, alpha = 1, showRange = false) {
        const { x, y } = Utils.gridToScreen(this.i, this.j, this.game.offsetX, this.game.offsetY);
        ctx.save();
        ctx.globalAlpha = alpha;
        // Draw tower shape
        ctx.beginPath();
        ctx.moveTo(x, y - CONSTANTS.TILE.HEIGHT);
        ctx.lineTo(x + CONSTANTS.TILE.WIDTH / 4, y);
        ctx.lineTo(x, y + CONSTANTS.TILE.HEIGHT / 4);
        ctx.lineTo(x - CONSTANTS.TILE.WIDTH / 4, y);
        ctx.closePath();
        ctx.fillStyle = this.spec.color;
        ctx.fill();
        // Draw left side of the tower (white with alpha)
        ctx.beginPath();
        ctx.moveTo(x, y - CONSTANTS.TILE.HEIGHT);
        ctx.lineTo(x - CONSTANTS.TILE.WIDTH / 4, y);
        ctx.lineTo(x, y + CONSTANTS.TILE.HEIGHT / 4);
        ctx.closePath();
        ctx.fillStyle = '#fff4';
        ctx.fill();
        // Draw level indicator with shadow
        ctx.fillStyle = 'yellow';
        ctx.font = '12px Arial';
        ctx.shadowColor = 'black';
        ctx.shadowBlur = 2;
        ctx.shadowOffsetX = 1;
        ctx.shadowOffsetY = 1;
        ctx.fillText(`Lv${this.level}`, x - 10, y - 20);
        ctx.shadowBlur = 0;
        ctx.shadowColor = 'transparent';
        // Draw range circle if requested
        if (showRange) {
          ctx.beginPath();
          ctx.ellipse(x, y, 
            this.spec.range * CONSTANTS.TILE.WIDTH / 2, 
            this.spec.range * CONSTANTS.TILE.HEIGHT / 2, 
            0, 0, Math.PI * 2
          );
          ctx.strokeStyle = '#8084';
          ctx.lineWidth = 1;
          ctx.stroke();
        }
        ctx.restore();
      }

      // Apply tower effects to enemies in range
      update(gameTime) {
        // Check cooldown
        if (gameTime - this.lastShot < this.spec.cooldown) return;
        // Get tower position
        const { x: tx, y: ty } = Utils.gridToScreen(this.i, this.j, this.game.offsetX, this.game.offsetY);
        // Find targets in range
        const targets = this.game.enemies
          .filter(e => Utils.distance(tx, ty, e.position.x, e.position.y) <= this.spec.range * CONSTANTS.TILE.WIDTH / 2)
          .sort((a, b) => Utils.distance(a.position.x, a.position.y, tx, ty) - Utils.distance(b.position.x, b.position.y, tx, ty));
        if (!targets.length) return;
        const target = targets[0];
        // Apply tower effect
        switch (this.spec.effect) {
          case 'damage':
            // Deal direct damage
            target.health -= this.spec.damage;
            this.game.effects.add('laser', { startX: tx, startY: ty, endX: target.position.x, endY: target.position.y }, 100);
            this.game.playSound('laser_shot'); // Play laser sound
            break;
          case 'slow':
            // Apply slow effect
            target.slowFactor = this.spec.slowFactor;
            target.slowEnd = gameTime + this.spec.slowDuration;
            if (this.spec.addFreeze) {
              target.speed = 0; // Freeze for 1s
              setTimeout(() => { if (target) target.speed = target.baseSpeed * target.slowFactor; }, 1000);
            }
            this.game.effects.add('slowAura', { x: target.position.x, y: target.position.y }, 100);
            this.game.playSound('slow_effect'); // Play slow effect sound
            break;
          case 'area':
            // Damage all targets in range
            targets.forEach(e => e.health -= this.spec.areaDamage);
            this.game.effects.add('areaPulse', { 
              x: tx, y: ty, 
              radiusX: this.spec.range * CONSTANTS.TILE.WIDTH / 2, 
              radiusY: this.spec.range * CONSTANTS.TILE.HEIGHT / 2 
            }, 200);
            this.game.playSound('area_blast'); // Play area blast sound
            break;
          case 'dot':
            // Apply damage-over-time
            target.dot = { damage: this.spec.dotDamage, end: gameTime + this.spec.dotDuration };
            this.game.effects.add('dotIndicator', { x: target.position.x, y: target.position.y }, 200);
            this.game.playSound('dot_effect'); // Play DoT effect sound
            break;
        }
        this.lastShot = gameTime;
      }
    }

    // Represents an enemy moving towards the base
    class Enemy {
      constructor(spawn, game, type) {
        this.game = game;             // Game instance
        this.type = type;             // Enemy type index
        const enemySpec = CONSTANTS.ENEMY_TYPES[type];
        let healthMultiplier = 1;
        if (game.endlessMode) {
          healthMultiplier = Math.pow(1.05, game.waveInLevel - CONSTANTS.MAX_WAVES_PER_LEVEL);
        }
        this.maxHealth = enemySpec.baseHealth +
                         enemySpec.healthPerLevel * (game.levelNumber - 1) +
                         game.waveInLevel * 8;
        this.maxHealth *= healthMultiplier;
        this.health = this.maxHealth;
        let speedMultiplier = 1;
        if (game.endlessMode) {
          speedMultiplier = 1 + 0.02 * (game.waveInLevel - CONSTANTS.MAX_WAVES_PER_LEVEL);
        }
        this.baseSpeed = enemySpec.speed * CONSTANTS.TILE.WIDTH / 1000 * speedMultiplier;
        this.speed = this.baseSpeed;
        this.damage = enemySpec.damage;
        this.color = enemySpec.color;
        this.radius = enemySpec.radius;
        this.reward = enemySpec.reward;
        // Calculate initial path
        this.path = Pathfinding.aStar(spawn, { i: 10, j: 10 }, game.grid, game.towers) || [];
        this.index = 0;               // Current path index
        this.reachedBase = !this.path.length; // Flag for reaching base
        // Set initial position
        this.position = Utils.gridToScreen(spawn.i, spawn.j, game.offsetX, game.offsetY);
        // Set initial target
        this.target = this.path[1] 
          ? Utils.gridToScreen(this.path[1].i, this.path[1].j, game.offsetX, game.offsetY) 
          : this.position;
        this.slowFactor = 1;          // Speed multiplier
        this.slowEnd = 0;             // Slow effect end time
        this.dot = null;              // Damage-over-time effect
      }

      // Draw enemy with health bar and status effects
      draw(ctx) {
        ctx.save();
        // Calculate movement direction
        const dx = this.target.x - this.position.x;
        const dy = this.target.y - this.position.y;
        const angle = Math.atan2(dy, dx);
        // Draw enemy body
        ctx.beginPath();
        ctx.arc(this.position.x, this.position.y, this.radius, 0, Math.PI * 2);
        ctx.fillStyle = this.color;
        ctx.fill();
        // Draw brighter part of body
        const offsetX = -0.3 * this.radius;
        const offsetY = -0.2 * this.radius;
        const brightRadius = 0.7 * this.radius;
        ctx.beginPath();
        ctx.arc(this.position.x + offsetX, this.position.y + offsetY, brightRadius, 0, Math.PI * 2);
        ctx.fillStyle = '#fff2';
        ctx.fill();
        // Draw two white elliptical eyes looking in walking direction
        ctx.save();
        ctx.translate(this.position.x, this.position.y);
        ctx.rotate(angle);
        const eyeOffsetX = 0.4 * this.radius;
        const eyeOffsetY = 0.3 * this.radius;
        const eyeWidth = 0.3 * this.radius;
        const eyeHeight = 0.2 * this.radius;
        // Left eye (relative to direction)
        ctx.beginPath();
        ctx.ellipse(eyeOffsetX, -eyeOffsetY, eyeWidth, eyeHeight, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
        // Right eye
        ctx.beginPath();
        ctx.ellipse(eyeOffsetX, eyeOffsetY, eyeWidth, eyeHeight, 0, 0, Math.PI * 2);
        ctx.fillStyle = 'white';
        ctx.fill();
        ctx.restore();
        // Draw health bar
        const barWidth = 2 * this.radius;
        const barX = this.position.x - barWidth / 2;
        const barY = this.position.y - this.radius - 5;
        ctx.fillStyle = '#ccc';
        ctx.fillRect(barX, barY, barWidth, 5);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(barX, barY, barWidth * Math.max(0, this.health / this.maxHealth), 5);
        ctx.restore();
        // Add slow effect visuals
        if (this.slowEnd > this.game.gameTime) {
          this.game.effects.add('slowAura', { x: this.position.x, y: this.position.y }, 50);
        }
        // Add DoT effect visuals
        if (this.dot && this.game.gameTime < this.dot.end && this.game.random.next() < 0.1) {
          this.game.effects.add('dotIndicator', { x: this.position.x, y: this.position.y }, 200);
        }
      }

      // Draw enemy's path to base
      drawPath(ctx) {
        if (this.path.length < 2) return;
        ctx.save();
        // Set dashed line style
        ctx.beginPath();
        ctx.setLineDash([5, 5]);
        ctx.strokeStyle = '#f002';
        ctx.lineWidth = 2;
        // Start at the position before the base
        const lastPoint = Utils.gridToScreen(this.path[this.path.length - 2].i, this.path[this.path.length - 2].j, this.game.offsetX, this.game.offsetY);
        ctx.moveTo(lastPoint.x, lastPoint.y);
        // Draw path segments up to but not including the base
        for (let i = this.path.length - 3; i >= this.index; i--) {
          const point = Utils.gridToScreen(this.path[i].i, this.path[i].j, this.game.offsetX, this.game.offsetY);
          ctx.lineTo(point.x, point.y);
        }
        // Connect to current position
        ctx.lineTo(this.position.x, this.position.y);
        ctx.stroke();
        ctx.setLineDash([]);
        ctx.restore();
      }

      // Update path to base
      updatePath() {
        // Get current grid position
        const currentGridPos = Utils.screenToGrid(
          this.position.x, 
          this.position.y, 
          this.game.offsetX, 
          this.game.offsetY
        );
        // Validate position
        if (!currentGridPos || !['gray'].includes(this.game.grid[currentGridPos.i][currentGridPos.j])) {
          this.reachedBase = true;
          this.path = [];
          return;
        }
        // Recalculate path
        this.path = Pathfinding.aStar(currentGridPos, { i: 10, j: 10 }, this.game.grid, this.game.towers) || [];
        this.index = 0;
        this.reachedBase = !this.path.length;
        // Update target
        this.target = this.path[1]
          ? Utils.gridToScreen(this.path[1].i, this.path[1].j, this.game.offsetX, this.game.offsetY)
          : this.position;
      }

      // Update enemy position and status
      update(gameTime, gameDeltaTime) {
        if (this.game.gameState === 'paused' || this.reachedBase) return;
        // Apply DoT (damage per second)
        if (this.dot && gameTime < this.dot.end) {
          this.health -= this.dot.damage * (gameDeltaTime / 1000);
        }
        // Update speed based on slow effect
        this.speed = this.baseSpeed * Math.max(0.1, gameTime > this.slowEnd ? 1 : this.slowFactor);
        // Calculate movement
        const moveDist = this.speed * gameDeltaTime;
        const dx = this.target.x - this.position.x;
        const dy = this.target.y - this.position.y;
        // Check if reached target
        if (Utils.distance(0, 0, dx, dy) <= moveDist) {
          this.index++;
          if (this.index >= this.path.length) {
            this.reachedBase = true;
            return;
          }
          this.position = { ...this.target };
          this.target = Utils.gridToScreen(this.path[this.index].i, this.path[this.index].j, this.game.offsetX, this.game.offsetY);
        } else {
          // Move towards target
          const angle = Math.atan2(dy, dx);
          this.position.x += Math.cos(angle) * moveDist;
          this.position.y += Math.sin(angle) * moveDist;
        }
      }
    }

    // Represents a single UI button (tower or action)
    class Button {
      constructor(config, game) {
        this.x = config.x;              // Button x position
        this.y = config.y || 630;       // Button y position (default for UI)
        this.width = config.width || 150;      // Button width
        this.height = config.height || 50;    // Button height
        this.text = config.text;        // Button text (function or string)
        this.type = config.type;        // Button type (tower, research, pause, speed, retry, upgrade, sell, endless)
        this.towerIndex = config.towerIndex; // Tower index for tower buttons
        this.isEnabled = config.isEnabled || (() => true); // Enabled condition
        this.isVisible = config.isVisible || (() => true); // Visibility condition
        this.onClick = config.onClick;   // Click handler function
        this.game = game;               // Game instance
      }

      // Check if point (x, y) is within button bounds
      isPointInside(x, y) {
        return x >= this.x && x < this.x + this.width &&
               y >= this.y && y < this.y + this.height;
      }

      // Render the button
      draw(ctx, towerIndex = null) {
        if (!this.isVisible(this.game)) return;

        const enabled = this.isEnabled(this.game);
        const text = typeof this.text === 'function' ? this.text(this.game) : this.text;

        ctx.save();
        if (this.type === 'tower') {
          // Render tower button
          ctx.fillStyle = enabled ? '#eee' : '#ccc';
          ctx.fillRect(this.x, this.y, this.width, this.height);
          // Draw tower preview
          ctx.save();
          ctx.translate(this.x + 25, this.y + 36);
          const tempTower = new Tower(0, 0, towerIndex, { ...this.game, offsetX: 0, offsetY: 0 });
          tempTower.draw(ctx, 1, false);
          ctx.restore();
          // Border style based on tower status
          ctx.strokeStyle = enabled
            ? (this.game.selectedTowerType === towerIndex ? 'yellow' : 'black')
            : 'gray';
          ctx.lineWidth = 2;
          ctx.strokeRect(this.x, this.y, this.width, this.height);
          // Tower button text
          ctx.fillStyle = enabled ? 'black' : 'gray';
          ctx.font = '12px Arial';
          ctx.fillText(text, this.x, this.y + 61);
        } else {
          // Render action button
          ctx.fillStyle = enabled ? '#eee' : 'gray';
          ctx.fillRect(this.x, this.y, this.width, this.height);
          // Action button text
          ctx.fillStyle = 'black';
          ctx.font = '16px Arial';
          ctx.fillText(text, this.x + 10, this.y + 30);
        }
        ctx.restore();
      }

      // Handle button click
      handleClick() {
        if (!this.isVisible(this.game) || !this.isEnabled(this.game)) return false;
        return this.onClick(this.game);
      }

      // Check if button is clickable for cursor style
      isClickable() {
        return this.isVisible(this.game) && this.isEnabled(this.game);
      }
    }

    // Manages all UI buttons
    class ButtonManager {
      constructor(game) {
        this.game = game;
        // Define tower button configurations
        this.TOWER_BUTTONS = CONSTANTS.TOWER_TYPES.map((tower, index) => ({
          x: 400 + index * 60,
          width: 50,
          text: `${tower.name} (${tower.cost})`,
          type: 'tower',
          towerIndex: index,
          isEnabled: game => game.unlockedTowers.includes(index),
          isVisible: game => ['playing', 'paused'].includes(game.gameState),
          onClick: game => {
            game.selectedTowerType = index;
            return true;
          }
        }));
        // Define action button configurations
        this.ACTION_BUTTONS = [
          {
            x: 700,
            text: 'Research (100)',
            type: 'research',
            isEnabled: game => game.money >= 100 && game.unlockedTowers.length < CONSTANTS.TOWER_TYPES.length,
            isVisible: game => ['playing', 'paused'].includes(game.gameState),
            onClick: game => {
              game.unlockTower();
              game.money -= 100;
              return true;
            }
          },
          {
            x: 860,
            text: game => game.gameState === 'paused' ? 'Resume' : 'Pause',
            type: 'pause',
            isEnabled: () => true,
            isVisible: game => ['playing', 'paused'].includes(game.gameState),
            onClick: game => {
              game.togglePause();
              return true;
            }
          },
          {
            x: 1020,
            text: game => game.speedMultiplier > 2 ? 'Speed x10  >>' : 'Speed x10',
            type: 'speed',
            isEnabled: () => true,
            isVisible: game => ['playing', 'paused'].includes(game.gameState),
            onClick: game => {
              game.speedMultiplier = game.speedMultiplier > 2 ? 1.5 : 15;
              return true;
            }
          },
          {
            x: 525,
            y: 450,
            text: 'Retry Level',
            type: 'retry',
            isEnabled: () => true,
            isVisible: game => game.gameState === 'gameover',
            onClick: game => {
              game.resetGame('retry');
              return true;
            }
          },
          {
            x: 10,
            y: 710,
            text: game => {
              if (!game.selectedTowerInstance) return '';
              const cost = game.selectedTowerInstance.getUpgradeCost();
              return `Upgrade (${cost === Infinity ? 'done' : cost})`;
            },
            type: 'upgrade',
            isEnabled: game => game.selectedTowerInstance && game.selectedTowerInstance.level < game.selectedTowerInstance.maxLevel && game.money >= game.selectedTowerInstance.getUpgradeCost(),
            isVisible: game => game.selectedTowerInstance !== null && ['playing', 'paused'].includes(game.gameState),
            onClick: game => {
              if (game.selectedTowerInstance.upgrade()) {
                // game.selectedTowerInstance = null;
                return true;
              }
              return false;
            }
          },
          {
            x: 170,
            y: 710,
            text: game => game.selectedTowerInstance ? `Sell (${Math.floor(CONSTANTS.TOWER_TYPES[game.selectedTowerInstance.type].cost / 2)})` : '',
            type: 'sell',
            isEnabled: () => true,
            isVisible: game => game.selectedTowerInstance !== null && ['playing', 'paused'].includes(game.gameState),
            onClick: game => {
              const idx = game.towers.findIndex(t => t === game.selectedTowerInstance);
              if (idx !== -1) {
                game.money += Math.floor(CONSTANTS.TOWER_TYPES[game.selectedTowerInstance.type].cost / 2);
                game.towers.splice(idx, 1);
                game.enemies.forEach(e => e.updatePath());
                game.playSound('tower_remove');
                game.selectedTowerInstance = null;
              }
              return true;
            }
          },
          {
            x: 200,
            y: 450,
            text: 'Retry Level',
            type: 'retryWin',
            width: 240,
            height: 50,
            isEnabled: () => true,
            isVisible: game => game.gameState === 'win',
            onClick: game => {
              game.resetGame('retry');
              return true;
            }
          },
          {
            x: 450,
            y: 445,
            text: 'Next Level',
            type: 'nextLevel',
            width: 300,
            height: 60,
            isEnabled: () => true,
            isVisible: game => game.gameState === 'win',
            onClick: game => {
              game.resetGame('nextLevel');
              return true;
            }
          },
          {
            x: 760,
            y: 450,
            text: 'Enter Endless Mode',
            type: 'endless',
            width: 240,
            height: 50,
            isEnabled: () => true,
            isVisible: game => game.gameState === 'win',
            onClick: game => {
              game.endlessMode = true;
              game.gameState = 'playing';
              game.startWave();
              return true;
            }
          }
        ];
        // Initialize buttons
        this.buttons = [...this.TOWER_BUTTONS, ...this.ACTION_BUTTONS].map(config => new Button(config, this.game));
      }

      // Handle button clicks. Returns true if a button was clicked
      handleButtonClick(x, y) {
        return this.buttons.some(button => button.isPointInside(x, y) && button.handleClick());
      }

      // Check if cursor should be pointer
      isCursorPointer(x, y) {
        return this.buttons.some(button => button.isPointInside(x, y) && button.isClickable());
      }

      // Draw all buttons
      draw(ctx, buttonType = null) {
        this.buttons.forEach(button => {
          if (buttonType && button.type !== buttonType) return;
          button.draw(ctx, button.towerIndex);
        });
      }
    }

    // Manages user interface elements
    class UIManager {
      constructor(game) {
        this.game = game;
        this.buttonManager = new ButtonManager(game);
      }

      // Render UI: stats and buttons
      draw(ctx) {
        // Draw UI background
        ctx.fillStyle = '#ccc';
        ctx.fillRect(0, CONSTANTS.UI.Y, this.game.canvas.width, CONSTANTS.UI.HEIGHT);
        // Draw game stats
        ctx.fillStyle = 'black';
        ctx.font = '20px Arial';
        ctx.fillText(`Money: ${this.game.money}`, 10, 640);
        ctx.fillText(`Base Health: ${this.game.baseHealth}`, 10, 670);
        let levelText = `Level: ${this.game.levelNumber}`;
        if (this.game.endlessMode) {
          levelText += ' (Endless)';
        }
        ctx.fillText(levelText, 200, 640);
        ctx.fillText(`Wave: ${(this.game.waveInLevel > 0) ? this.game.waveInLevel : '1'}`, 200, 670);
        ctx.fillText(`Enemies Left: ${this.game.enemies.length + this.game.spawnQueue.length}`, 10, 700);
         // Draw buttons
        this.buttonManager.draw(ctx);
        // // Draw selected tower info
        // if (this.game.selectedTowerInstance) {
        //   ctx.fillText(`Selected: ${CONSTANTS.TOWER_TYPES[this.game.selectedTowerInstance.type].name} Lv${this.game.selectedTowerInstance.level}`, 420, 730);
        // }
      }

      // Show tower placement preview
      drawPreview(ctx) {
        if (this.game.selectedTowerType === null || !this.game.cursorPos) return;
        const { i, j } = this.game.cursorPos;
        // Draw preview if placement is valid
        if (this.game.canPlaceTower(i, j) && this.game.money >= CONSTANTS.TOWER_TYPES[this.game.selectedTowerType].cost) {
          new Tower(i, j, this.game.selectedTowerType, this.game).draw(ctx, 0.7, true);
        }
      }

      // Render win screen
      drawWinScreen(ctx) {
        ctx.save();
        ctx.fillStyle = '#0008';
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        ctx.fillStyle = '#fffe';
        ctx.textAlign = 'center';
        ctx.font = '60px Arial';
        ctx.fillText('Level Complete!', this.game.canvas.width / 2, this.game.canvas.height / 2 - 60);
        ctx.font = '20px Arial';
        ctx.fillText('Proceed to next level, enter endless mode, or retry level', this.game.canvas.width / 2, this.game.canvas.height / 2);
        ctx.restore();
        this.buttonManager.buttons.filter(button => ['endless', 'nextLevel', 'retryWin'].includes(button.type)).forEach(button => button.draw(ctx, button.towerIndex));
      }

      // Render game over screen
      drawGameOverScreen(ctx) {
        ctx.save();
        ctx.fillStyle = '#0008';
        ctx.fillRect(0, 0, this.game.canvas.width, this.game.canvas.height);
        ctx.fillStyle = '#fffe';
        ctx.textAlign = 'center';
        ctx.font = '60px Arial';
        ctx.fillText('Game Over', this.game.canvas.width / 2, this.game.canvas.height / 2 - 30);
        ctx.font = '20px Arial';
        ctx.fillText('You can always retry the level', this.game.canvas.width / 2, this.game.canvas.height / 2 + 20);
        ctx.restore();
        this.buttonManager.draw(ctx, 'retry'); // Draw retry button
      }
    }

    // Main game logic and state management
    class Game {
      constructor() {
        // Initialize canvas and context
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d');
        this.offsetX = 600; // Grid offset X
        this.offsetY = 0;   // Grid offset Y
        this.ui = new UIManager(this); // UI manager
        this.isFullscreen = false; // Track fullscreen state
        this.cheatBuffer = ''; // Initialize cheat buffer

        // Initialize Web Audio API
        this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
        // Gain node for background "music"
        this.backgroundGain = this.audioContext.createGain();
        this.backgroundGain.gain.setValueAtTime(0.1, this.audioContext.currentTime); // 10% volume
        this.backgroundGain.connect(this.audioContext.destination);
        // Gain node for sound effects
        this.effectGain = this.audioContext.createGain();
        this.effectGain.gain.setValueAtTime(0.5, this.audioContext.currentTime); // 50% volume
        this.effectGain.connect(this.audioContext.destination);
        // Reference to background audio element
        this.backgroundAudio = document.getElementById('backgroundAudio');
        this.backgroundSource = null;
        // Storage for sound effect audio buffers
        this.soundEffects = {
          laser_shot: null,
          slow_effect: null,
          area_blast: null,
          dot_effect: null,
          enemy_spawn: null,
          tower_place: null
        };

        // Load audio files
        this.loadAudioFiles();

        // Initialize game state
        this.resetGame('full');

        // Setup event listeners
        this.setupEvents();

        // Start game loop
        requestAnimationFrame(this.loop.bind(this));
      }

      // Scale canvas to fit window while maintaining aspect ratio
      scaleCanvas() {
        const canvasWidth = 1200;
        const canvasHeight = 770;
        const aspectRatio = canvasWidth / canvasHeight;

        // Get window dimensions
        const windowWidth = window.innerWidth;
        const windowHeight = window.innerHeight;
        const windowAspectRatio = windowWidth / windowHeight;

        let newWidth, newHeight;
        if (windowWidth < canvasWidth || windowHeight < canvasHeight) {
          // Window is smaller than canvas, scale down to fit
          if (windowAspectRatio > aspectRatio) {
            // Window is wider than canvas, fit to height
            newHeight = windowHeight;
            newWidth = newHeight * aspectRatio;
          } else {
            // Window is taller than canvas, fit to width
            newWidth = windowWidth;
            newHeight = newWidth / aspectRatio;
          }
        } else {
          // Window is larger than canvas, use original size
          newWidth = canvasWidth;
          newHeight = canvasHeight;
        }

        this.canvas.style.width = `${newWidth}px`;
        this.canvas.style.height = `${newHeight}px`;
      }

      // Toggle fullscreen and orientation
      toggleFullscreen() {
        if (!this.isFullscreen) {
          // Enter fullscreen
          document.documentElement.requestFullscreen().catch(e => console.error('Fullscreen request failed:', e));
          // Lock to landscape orientation
          if (screen.orientation && screen.orientation.lock) {
            screen.orientation.lock('landscape').catch(e => console.error('Orientation lock failed:', e));
          }
          this.isFullscreen = true;
        } else {
          // Exit fullscreen
          if (document.fullscreenElement) {
            document.exitFullscreen().catch(e => console.error('Exit fullscreen failed:', e));
          }
          // Unlock orientation
          if (screen.orientation && screen.orientation.unlock) {
            screen.orientation.unlock();
          }
          this.isFullscreen = false;
        }
        // Scale canvas after fullscreen change
        this.scaleCanvas();
      }

      // Load background and sound effect audio files
      async loadAudioFiles() {
        // Setup background audio
        try {
          this.backgroundSource = this.audioContext.createMediaElementSource(this.backgroundAudio);
          this.backgroundSource.connect(this.backgroundGain);
        } catch (e) {
          console.error('Error setting up background audio:', e);
        }

        // Load sound effect files
        const soundFiles = [
          { key: 'laser_shot', url: 'sound/laser_shot.mp3' },
          { key: 'slow_effect', url: 'sound/slow_effect.mp3' },
          { key: 'area_blast', url: 'sound/area_blast.mp3' },
          { key: 'dot_effect', url: 'sound/dot_effect.mp3' },
          { key: 'enemy_spawn', url: 'sound/enemy_spawn.mp3' },
          { key: 'tower_place', url: 'sound/tower_place.mp3' },
          { key: 'tower_remove', url: 'sound/tower_remove.mp3' },
          { key: 'enemy_at_base', url: 'sound/enemy_at_base.mp3' }
        ];

        for (const { key, url } of soundFiles) {
          try {
            const response = await fetch(url);
            const arrayBuffer = await response.arrayBuffer();
            this.soundEffects[key] = await this.audioContext.decodeAudioData(arrayBuffer);
          } catch (e) {
            console.error(`Error loading sound effect ${key}:`, e);
          }
        }
      }

      // Play a sound effect
      playSound(key) {
        const buffer = this.soundEffects[key];
        if (buffer && this.audioContext.state === 'running') {
          const source = this.audioContext.createBufferSource();
          source.buffer = buffer;
          source.connect(this.effectGain);
          source.start(0);
        }
      }

      // Resume audio context and start background audio on user interaction
      resumeAudioContext() {
        const playAudio = () => this.gameState === 'playing' && this.backgroundAudio.play()
          .catch(e => console.error('Background audio play failed:', e));
        if (this.audioContext.state === 'suspended') {
          this.audioContext.resume().then(playAudio).catch(e => console.error('AudioContext resume failed:', e));
        } else {
          playAudio();
        }
      }

      // Toggle pause state
      togglePause() {
        if (this.gameState === 'playing') {
          this.gameState = 'paused';
          this.backgroundAudio.pause();
        } else if (this.gameState === 'paused') {
          this.gameState = 'playing';
          this.backgroundAudio.play().catch(e => console.error('Background audio play failed:', e));
        }
      }

      // Reset game state based on mode: full, retry, nextLevel, or setLevel
      resetGame(mode, levelNumber = null) {
        if (this.backgroundAudio && !this.backgroundAudio.paused) {
          this.backgroundAudio.pause();
        }
        Object.assign(this, {
          money: CONSTANTS.INITIAL_MONEY,
          baseHealth: CONSTANTS.BASE_HEALTH,
          waveInLevel: 0,
          towers: [],
          enemies: [],
          spawnQueue: [],
          waveActive: false,
          lastWaveTime: this.gameTime || 0,
          gameState: 'playing',
          effects: new EffectManager(),
          selectedTowerType: 0,
          selectedTowerInstance: null,
          cursorPos: null,
          hoveredTower: null,
          gameTime: 0,
          previousTime: 0,
          speedMultiplier: 1.5,
          endlessMode: false,
          cheatBuffer: ''
        });

        // Mode-specific adjustments
        if (mode === 'full') {
          // Full reset: Start from level 1, reset towers
          this.levelNumber = 1;
          this.unlockedTowers = [0];
        } else if (mode === 'retry') {
          // Retry level: Keep level number and unlocked towers
          // No changes needed, as levelNumber and unlockedTowers are preserved
        } else if (mode === 'nextLevel') {
          // Next level: Increment level, keep unlocked towers
          this.levelNumber++;
        } else if (mode === 'setLevel' && levelNumber !== null) {
          // Set specific level: Use provided level number, reset towers
          this.levelNumber = levelNumber;
        }

        this.random = new SeededRandom(12345 + this.levelNumber);
        this.unlockRandom = new SeededRandom(12345 + this.levelNumber);
        this.grid = this.generateCity();

        // Start initial wave
        this.startWave();
        // Resume background audio after reset
        if (this.audioContext.state === 'running' && this.gameState === 'playing') {
          this.backgroundAudio.play().catch(e => console.error('Background audio play failed:', e));
        }
        // Reset canvas scaling
        this.scaleCanvas();
      }

      // Create city grid with streets, buildings, and base
      generateCity() {
        // Initialize grid with buildings
        const grid = Array(CONSTANTS.GRID_SIZE).fill()
          .map(() => Array(CONSTANTS.GRID_SIZE).fill(CONSTANTS.COLORS.BUILDING));
        // Add streets
        [0, 5, 10, 15, 19].forEach(i => {
          for (let j = 0; j < CONSTANTS.GRID_SIZE; j++) {
            grid[i][j] = grid[j][i] = CONSTANTS.COLORS.STREET;
          }
        });
        // Set base position
        grid[10][10] = CONSTANTS.COLORS.BASE;
        // Add parking lots near streets
        for (let i = 0; i < CONSTANTS.GRID_SIZE; i++) {
          for (let j = 0; j < CONSTANTS.GRID_SIZE; j++) {
            if (grid[i][j] === CONSTANTS.COLORS.BUILDING && this.random.next() < 0.3 && 
                ([i-1, i+1].some(x => x >= 0 && x < CONSTANTS.GRID_SIZE && grid[x][j] === CONSTANTS.COLORS.STREET) ||
                 [j-1, j+1].some(y => y >= 0 && y < CONSTANTS.GRID_SIZE && grid[i][y] === CONSTANTS.COLORS.STREET))) {
              grid[i][j] = CONSTANTS.COLORS.PARKING_LOT;
            }
          }
        }
        return grid;
      }

      // Render a single grid tile
      drawTile(i, j) {
        const { x, y } = Utils.gridToScreen(i, j, this.offsetX, this.offsetY);
        this.ctx.save();
        // Draw tile shape
        this.ctx.beginPath();
        this.ctx.moveTo(x, y - CONSTANTS.TILE.HEIGHT / 2);
        this.ctx.lineTo(x + CONSTANTS.TILE.WIDTH / 2, y);
        this.ctx.lineTo(x, y + CONSTANTS.TILE.HEIGHT / 2);
        this.ctx.lineTo(x - CONSTANTS.TILE.WIDTH / 2, y);
        this.ctx.closePath();
        // Set tile color
        let fillColor = this.grid[i][j];
        if (fillColor === CONSTANTS.COLORS.BUILDING) {
          const hue = 120 + ((this.levelNumber * 133) % 103) - 50;
          fillColor = `hsl(${hue}, 50%, 33%)`;
        }
        this.ctx.fillStyle = fillColor;
        this.ctx.fill();
        this.ctx.restore();
      }

      // Redraw entire game state
      render() {
        // Clear canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        // Draw grid
        for (let i = 0; i < CONSTANTS.GRID_SIZE; i++) {
          for (let j = 0; j < CONSTANTS.GRID_SIZE; j++) {
            this.drawTile(i, j);
          }
        }
        // Draw towers, enemies, enemy paths, effects, and UI
        this.enemies.forEach(e => e.drawPath(this.ctx));
        this.enemies.forEach(e => e.draw(this.ctx));
        if (this.gameState === 'playing') {
          this.effects.draw(this.ctx);
        }
        this.towers.forEach(t => {
          const showRange = this.hoveredTower && t.i === this.hoveredTower.i && t.j === this.hoveredTower.j ||
                            this.selectedTowerInstance === t;
          t.draw(this.ctx, 1, showRange);
        });
        if (['playing', 'paused'].includes(this.gameState)) {
          this.ui.drawPreview(this.ctx);
        }
        this.ui.draw(this.ctx);
        if (this.gameState === 'win') {
          this.ui.drawWinScreen(this.ctx);
        } else if (this.gameState === 'gameover') {
          this.ui.drawGameOverScreen(this.ctx);
        }
      }

      // Check if tower placement is valid
      canPlaceTower(i, j) {
        // Check tile type and existing towers
        if (![CONSTANTS.COLORS.STREET, CONSTANTS.COLORS.PARKING_LOT].includes(this.grid[i][j]) || 
            this.towers.some(t => t.i === i && t.j === j)) {
          return false;
        }
        // Test pathfinding with temporary tower
        const tempTowers = [...this.towers, { i, j }];
        const borders = [];
        for (let k = 0; k < CONSTANTS.GRID_SIZE; k++) {
          if (this.grid[0][k] === CONSTANTS.COLORS.STREET) borders.push({ i: 0, j: k });
          if (this.grid[CONSTANTS.GRID_SIZE - 1][k] === CONSTANTS.COLORS.STREET) borders.push({ i: CONSTANTS.GRID_SIZE - 1, j: k });
          if (this.grid[k][0] === CONSTANTS.COLORS.STREET) borders.push({ i: k, j: 0 });
          if (this.grid[k][CONSTANTS.GRID_SIZE - 1] === CONSTANTS.COLORS.STREET) borders.push({ i: k, j: CONSTANTS.GRID_SIZE - 1 });
        }
        // Ensure all border points can reach base
        return borders.every(b => Pathfinding.aStar(b, { i: 10, j: 10 }, this.grid, tempTowers));
      }

      // Initiate a new enemy wave
      startWave() {
        this.waveInLevel++;
        this.waveActive = true;
        // Select spawn points
        const borders = [];
        for (let k = 0; k < CONSTANTS.GRID_SIZE; k++) {
          if (this.grid[0][k] === CONSTANTS.COLORS.STREET) borders.push({ i: 0, j: k });
          if (this.grid[CONSTANTS.GRID_SIZE - 1][k] === CONSTANTS.COLORS.STREET) borders.push({ i: CONSTANTS.GRID_SIZE - 1, j: k });
          if (this.grid[k][0] === CONSTANTS.COLORS.STREET) borders.push({ i: k, j: 0 });
          if (this.grid[k][CONSTANTS.GRID_SIZE - 1] === CONSTANTS.COLORS.STREET) borders.push({ i: k, j: CONSTANTS.GRID_SIZE - 1 });
        }
        const spawns = [];
        for (let i = 0; i < Math.min(this.waveInLevel, 4); i++) {
          const index = this.random.nextInt(0, borders.length);
          spawns.push(borders.splice(index, 1)[0]);
        }
        // Calculate total spawns
        const total = spawns.length * 3;
        // Determine available enemy types
        const maxType = Math.min(CONSTANTS.ENEMY_TYPES.length - 1, Math.floor((this.waveInLevel - 1) / 5));
        // Calculate sum of spawn multipliers
        const spawnMultiplierSum = CONSTANTS.ENEMY_TYPES.slice(0, maxType + 1)
          .reduce((sum, type) => sum + type.spawnMultiplier, 0);
        // Calculate spawn counts per type
        let spawnsLeft = Math.floor(total * spawnMultiplierSum);
        const spawnCounts = Array(maxType + 1).fill(0);
        for (let type = maxType; type >= 0; type--) {
          spawnCounts[type] = Math.min(
            Math.max(1, Math.floor(this.random.next() * (CONSTANTS.ENEMY_TYPES[type].spawnMultiplier * total) + 1)),
            spawnsLeft
          );
          spawnsLeft -= spawnCounts[type];
        }
        spawnCounts[0] = Math.max(1, spawnsLeft); // Assign remaining spawns to Basic
        // Populate spawn queue
        const interval = Math.max(500, 1000 - this.waveInLevel * 50);
        let spawnIndex = 0;
        for (let type = 0; type <= maxType; type++) {
          for (let i = 0; i < spawnCounts[type]; i++) {
            const spawnTime = this.gameTime + spawnIndex * interval;
            const spawnPos = spawns[spawnIndex % spawns.length];
            this.spawnQueue.push({ time: spawnTime, pos: spawnPos, type });
            spawnIndex++;
          }
        }
      }

      // Update game state
      update(gameTime, gameDeltaTime) {
        if (this.gameState !== 'playing') return;
        // Spawn enemies from queue
        while (this.spawnQueue.length && gameTime >= this.spawnQueue[0].time) {
          const spawn = this.spawnQueue.shift();
          this.enemies.push(new Enemy(spawn.pos, this, spawn.type));
          this.playSound('enemy_spawn');
        }
        // Start new wave
        if (!this.waveActive && !this.enemies.length && gameTime - this.lastWaveTime > 5000) {
          this.startWave();
        }
        // Update towers and enemies
        this.towers.forEach(t => t.update(gameTime));
        this.enemies.forEach(e => e.update(gameTime, gameDeltaTime));
        // Remove dead enemies or those that reached base
        this.enemies = this.enemies.filter(e => {
          if (e.reachedBase) {
            this.baseHealth -= e.damage;
            this.playSound('enemy_at_base');
            return false;
          }
          if (e.health <= 0) {
            this.money += e.reward;
            return false;
          }
          return true;
        });
        // End wave
        if (this.waveActive && !this.enemies.length && this.spawnQueue.length === 0) {
          this.waveActive = false;
          this.lastWaveTime = gameTime;
          this.money += 50;
          // Check for level completion
          if (this.waveInLevel >= CONSTANTS.MAX_WAVES_PER_LEVEL && !this.endlessMode) {
            this.gameState = 'win';
          }
        }
        this.effects.update(performance.now());
      }

      // Handle mouse interactions
      setupEvents() {
        this.canvas.addEventListener('mousedown', e => {
          // Resume audio context on first user interaction
          this.resumeAudioContext();
          const rect = this.canvas.getBoundingClientRect();
          // Calculate scaling factors
          const scaleX = this.canvas.width / (rect.width || 1); // Avoid division by zero
          const scaleY = this.canvas.height / (rect.height || 1);
          // Adjust coordinates for canvas scaling
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;
          
          if (e.button === 0) { // Left click
            if (this.gameState === 'win') {
              this.ui.buttonManager.handleButtonClick(x, y);
            } else if (this.gameState === 'gameover') {
              this.ui.buttonManager.handleButtonClick(x, y);
            } else {
              if (this.ui.buttonManager.handleButtonClick(x, y)) {
                return;
              }
              // Select existing tower or place new one
              const pos = Utils.screenToGrid(x, y, this.offsetX, this.offsetY);
              if (pos && y < CONSTANTS.UI.Y) {
                const existingTower = this.towers.find(t => t.i === pos.i && t.j === pos.j);
                if (existingTower) {
                  this.selectedTowerInstance = existingTower;
                  return;
                } 
              }
              // Place tower if no existing selected
              if (pos && this.selectedTowerType !== null && 
                  this.money >= CONSTANTS.TOWER_TYPES[this.selectedTowerType].cost && 
                  this.canPlaceTower(pos.i, pos.j)) {
                const newTower = new Tower(pos.i, pos.j, this.selectedTowerType, this);
                // Insert tower in sorted order based on i + j to ensure correct rendering depth
                const insertIndex = this.towers.findIndex(t => (t.i + t.j) > (pos.i + pos.j));
                if (insertIndex === -1) {
                  this.towers.push(newTower);
                } else {
                  this.towers.splice(insertIndex, 0, newTower);
                }
                this.money -= CONSTANTS.TOWER_TYPES[this.selectedTowerType].cost;
                this.enemies.forEach(e => e.updatePath());
                this.playSound('tower_place');
              } else if (pos && y < CONSTANTS.UI.Y) {
                this.selectedTowerInstance = null;
              }
            }
          } else if (e.button === 2) { // Right click
            // Deselect or remove tower
            if (this.selectedTowerInstance) {
              this.selectedTowerInstance = null;
              return;
            }
            const pos = Utils.screenToGrid(x, y, this.offsetX, this.offsetY);
            if (pos) {
              const idx = this.towers.findIndex(t => t.i === pos.i && t.j === pos.j);
              if (idx !== -1) {
                this.money += Math.floor(CONSTANTS.TOWER_TYPES[this.towers[idx].type].cost / 2);
                this.towers.splice(idx, 1);
                this.enemies.forEach(e => e.updatePath());
                this.playSound('tower_remove');
              }
            }
          }
        });
        
        // Update cursor position and hovered tower
        this.canvas.addEventListener('mousemove', e => {
          const rect = this.canvas.getBoundingClientRect();
          // Calculate scaling factors
          const scaleX = this.canvas.width / (rect.width || 1); // Avoid division by zero
          const scaleY = this.canvas.height / (rect.height || 1);
          // Adjust coordinates for canvas scaling
          const x = (e.clientX - rect.left) * scaleX;
          const y = (e.clientY - rect.top) * scaleY;
          this.cursorPos = Utils.screenToGrid(x, y, this.offsetX, this.offsetY);
          // Update hovered tower
          this.hoveredTower = null;
          if (this.cursorPos && y < CONSTANTS.UI.Y) {
            this.hoveredTower = this.towers.find(t => t.i === this.cursorPos.i && t.j === this.cursorPos.j) || null;
          }
          // Change cursor style for clickable areas
          this.canvas.style.cursor = this.ui.buttonManager.isCursorPointer(x, y) ? 'pointer' : 'default';
        });

        // Prevent context menu on right-click
        this.canvas.addEventListener('contextmenu', e => e.preventDefault());

        // Setup fullscreen button event
        const fullscreenButton = document.getElementById('fullscreenButton');
        fullscreenButton.addEventListener('click', () => {
          this.toggleFullscreen();
        });

        // Add keypress event listener
        document.addEventListener('keypress', e => {
          // Space bar toggles pause
          if (e.key === ' ') this.togglePause();
          // Tower selection with keys 1, 2, 3, 4
          if (['1', '2', '3', '4'].includes(e.key)) {
            const towerIndex = parseInt(e.key) - 1;
            if (this.unlockedTowers.includes(towerIndex)) {
              this.selectedTowerType = towerIndex;
              this.selectedTowerInstance = null;
            }
          }
          // Toggle speed x10 with 's' key
          if (e.key.toLowerCase() === 's') {
            this.speedMultiplier = this.speedMultiplier > 2 ? 1.5 : 15;
          }
          // Cheat code handling
          this.cheatBuffer += e.key.toLowerCase();
          // Keep only the last 5 characters to match "level", "tower", and "money"
          if (this.cheatBuffer.length > 5) {
            this.cheatBuffer = this.cheatBuffer.slice(-5);
          }
          if (this.cheatBuffer === 'level') {
            const input = prompt('Enter level number (1 or higher):', this.levelNumber);
            if (input !== null) {
              const newLevel = parseInt(input, 10);
              if (!isNaN(newLevel) && newLevel >= 1) {
                this.resetGame('setLevel', newLevel);
              } else {
                alert('Please enter a valid level number (1 or higher).');
              }
            }
            this.cheatBuffer = '';
          } else if (this.cheatBuffer === 'tower') {
            // Unlock all towers
            this.unlockedTowers = CONSTANTS.TOWER_TYPES.map((_, i) => i);
            this.cheatBuffer = '';
          } else if (this.cheatBuffer === 'money') {
            // Unlock all towers
            this.money += 5000;
            this.cheatBuffer = '';
          }
        });
      }

      // Unlock a random tower
      unlockTower() {
        const locked = CONSTANTS.TOWER_TYPES.map((_, i) => i)
          .filter(i => !this.unlockedTowers.includes(i));
        if (locked.length) {
          const index = this.unlockRandom.nextInt(0, locked.length);
          this.unlockedTowers.push(locked[index]);
        }
      }

      // Main game loop
      loop(time) {
        // Check for game over
        if (this.baseHealth <= 0 && this.gameState === 'playing') {
          this.gameState = 'gameover';
        }
        // Pause background audio on win or game over
        if (['win', 'gameover'].includes(this.gameState) && !this.backgroundAudio.paused) {
          this.backgroundAudio.pause();
        }
        // Initialize previousTime on first frame
        if (this.previousTime === 0) this.previousTime = time;
        // Calculate real delta and game delta
        const deltaTime = time - this.previousTime;
        this.previousTime = time;
        const gameDeltaTime = deltaTime * this.speedMultiplier;
        this.gameTime += gameDeltaTime;
        // Update and render
        this.update(this.gameTime, gameDeltaTime);
        this.render();
        requestAnimationFrame(this.loop.bind(this));
      }
    }

    // Initialize and start the game
    new Game();
  </script>
</body>
</html>
